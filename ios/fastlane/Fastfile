# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

platform :ios do
  before_all do
    # Setup CI environment when running on CI
    if ENV['CI']
      setup_ci
    end
  end

  desc "Load App Store Connect API Key"
  private_lane :load_asc_api_key do
    app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY"],
      duration: 1200, # optional (maximum 1200)
      in_house: false # optional but may be required if using match/sigh
    )
  end

  desc "Sync certificates and provisioning profiles"
  lane :sync_certificates do
    load_asc_api_key
    match(
      type: "appstore",
      platform: "ios",
      force: ENV['MATCH_FORCE_WRITE'] == 'true',
      readonly: ENV['CI'] && (ENV['MATCH_FORCE_WRITE'] != true && ENV['MATCH_FORCE_WRITE'] != 'true'),
      keychain_name: ENV['CI'] ? 'build.keychain' : 'login.keychain',
      keychain_password: ENV['CI'] ? '' : nil
    )
  end

  desc "Build the app for release"
  lane :build_release do
    # Load signing certificates
    sync_certificates
    
    # Verify certificate installation
    sh("security find-identity -v -p codesigning build.keychain")
    
    # Increment build number based on current timestamp (more reliable than latest_testflight_build_number)
    build_number = Time.now.strftime("%Y%m%d%H%M")
    increment_build_number(
      build_number: build_number,
      xcodeproj: "App/App.xcodeproj"
    )
    
    # Build the app with Xcode 16 compatibility fixes
    build_app(
      scheme: "App",
      workspace: "App/App.xcworkspace",
      configuration: "Release",
      export_method: "app-store",
      codesigning_identity: "Apple Distribution",
      clean: true, # Clean build for Xcode 16 compatibility
      include_bitcode: false, # Bitcode deprecated in Xcode 16
      include_symbols: true,
      xcargs: "CODE_SIGN_IDENTITY='Apple Distribution' CODE_SIGN_STYLE=Manual PROVISIONING_PROFILE_SPECIFIER='match AppStore app.cawcaw' OTHER_CODE_SIGN_FLAGS='--keychain build.keychain' -allowProvisioningUpdates",
      export_options: {
        method: "app-store",
        signingStyle: "manual",
        provisioningProfiles: {
          "app.cawcaw" => "match AppStore app.cawcaw"
        },
        signingCertificate: "Apple Distribution",
        compileBitcode: false, # Explicitly disable bitcode for Xcode 16
        uploadBitcode: false,
        uploadSymbols: true,
        thinning: "<none>"
      }
    )
  end

  desc "Upload to TestFlight"
  lane :upload_testflight do
    load_asc_api_key
    
    # Explicitly configure iTMSTransporter environment variables for upload reliability
    # Use DAV transport to avoid OSStatus -10814 errors
    ENV["DELIVER_ITMSTRANSPORTER_ADDITIONAL_UPLOAD_PARAMETERS"] = "-t DAV"
    ENV["ITMSTRANSPORTER_FORCE_ITMS_PACKAGE_UPLOAD"] = "true"
    
    # Use shell script mode if specified by CI (avoids Java dependency issues)
    if ENV["FASTLANE_ITUNES_TRANSPORTER_USE_SHELL_SCRIPT"]
      UI.message "üîß Using iTMSTransporter shell script mode"
    end
    
    if ENV["FASTLANE_ITUNES_TRANSPORTER_PATH"]
      UI.message "üîß Using iTMSTransporter path: #{ENV["FASTLANE_ITUNES_TRANSPORTER_PATH"]}"
    end
    
    # Upload with retry mechanism for network issues
    retry_count = 3
    begin
      pilot(
        ipa: "./App.ipa",
        skip_waiting_for_build_processing: true,
        skip_submission: true,
        distribute_external: false,
        notify_external_testers: false,
        changelog: "Built with GitHub Actions",
        reject_build_waiting_for_review: true,
        uses_non_exempt_encryption: false
      )
    rescue => e
      if retry_count > 0 && e.message.include?("OSStatus error -10814")
        UI.important "üîÑ OSStatus -10814 error detected. Retrying upload... (#{retry_count} attempts remaining)"
        retry_count -= 1
        sleep(30) # Wait 30 seconds before retry
        retry
      else
        raise e
      end
    end
  end

  desc "Build and upload to TestFlight"
  lane :beta do
    build_release
    upload_testflight
    
    # Send success notification
    if ENV['CI']
      puts "‚úÖ Successfully uploaded build to TestFlight!"
      puts "üîó Check your build at: https://appstoreconnect.apple.com"
    end
  end

  desc "Build for local testing"
  lane :build_local do
    load_asc_api_key
    match(type: "development")
    build_app(
      scheme: "App",
      workspace: "App/App.xcworkspace",
      export_method: "development"
    )
  end

  desc "Generate iOS app icons from source"
  lane :generate_icons do
    # Source icon path (relative to ios directory)
    source_icon = "../ios-icon.png"
    app_icon_path = "App/App/Assets.xcassets/AppIcon.appiconset"
    
    # Generate all required iOS icon sizes using ImageMagick
    UI.message "üé® Generating iOS app icons from #{source_icon}..."
    
    # iPhone notification icons (20pt)
    sh("magick #{source_icon} -resize 40x40 #{app_icon_path}/AppIcon-20@2x.png")
    sh("magick #{source_icon} -resize 60x60 #{app_icon_path}/AppIcon-20@3x.png")
    
    # Settings icons (29pt)
    sh("magick #{source_icon} -resize 58x58 #{app_icon_path}/AppIcon-29@2x.png")
    sh("magick #{source_icon} -resize 87x87 #{app_icon_path}/AppIcon-29@3x.png")
    
    # Spotlight icons (40pt)
    sh("magick #{source_icon} -resize 80x80 #{app_icon_path}/AppIcon-40@2x.png")
    sh("magick #{source_icon} -resize 120x120 #{app_icon_path}/AppIcon-40@3x.png")
    
    # App icons (60pt)
    sh("magick #{source_icon} -resize 120x120 #{app_icon_path}/AppIcon-60@2x.png")
    sh("magick #{source_icon} -resize 180x180 #{app_icon_path}/AppIcon-60@3x.png")
    
    # iPad icons
    sh("magick #{source_icon} -resize 20x20 #{app_icon_path}/AppIcon-20@1x.png")
    sh("magick #{source_icon} -resize 29x29 #{app_icon_path}/AppIcon-29@1x.png")
    sh("magick #{source_icon} -resize 40x40 #{app_icon_path}/AppIcon-40@1x.png")
    
    # Marketing icon (1024x1024) - only if doesn't exist
    marketing_icon = "#{app_icon_path}/AppIcon-1024.png"
    unless File.exist?(marketing_icon)
      sh("magick #{source_icon} -resize 1024x1024 #{marketing_icon}")
    end
    
    UI.success "‚úÖ iOS app icons generated successfully!"
    UI.message "üìÅ Icons saved to: #{app_icon_path}/"
  end

  desc "Download certificates for development"
  lane :certificates_development do
    load_asc_api_key
    match(
      type: "development",
      platform: "ios"
    )
  end

  desc "Download certificates for distribution"
  lane :certificates_distribution do
    load_asc_api_key
    match(
      type: "appstore",
      platform: "ios",
      readonly: ENV['CI'] && (ENV['MATCH_FORCE_WRITE'] != true && ENV['MATCH_FORCE_WRITE'] != 'true'),
      keychain_name: ENV['CI'] ? 'build.keychain' : 'login.keychain',
      keychain_password: ENV['CI'] ? '' : nil
    )
  end

  # ==========================================
  # Ad Hoc Distribution Lanes
  # ==========================================
  
  desc "Sync Ad Hoc certificates and provisioning profiles"
  lane :sync_certificates_adhoc do
    load_asc_api_key
    match(
      type: "adhoc",
      platform: "ios",
      force: ENV['MATCH_FORCE_WRITE'] == 'true',
      readonly: ENV['CI'] && (ENV['MATCH_FORCE_WRITE'] != true && ENV['MATCH_FORCE_WRITE'] != 'true')
    )
  end

  desc "Download certificates for Ad Hoc distribution"
  lane :certificates_adhoc do
    load_asc_api_key
    match(
      type: "adhoc",
      platform: "ios",
      readonly: ENV['CI'] && (ENV['MATCH_FORCE_WRITE'] != true && ENV['MATCH_FORCE_WRITE'] != 'true')
    )
  end

  desc "Build the app for Ad Hoc distribution"
  lane :build_adhoc do
    # Load signing certificates for Ad Hoc
    sync_certificates_adhoc
    
    # Increment build number based on timestamp for Ad Hoc builds
    build_number = Time.now.strftime("%Y%m%d%H%M")
    increment_build_number(
      build_number: build_number,
      xcodeproj: "App/App.xcodeproj"
    )
    
    # Build the app for Ad Hoc distribution with Xcode 16 compatibility
    build_app(
      scheme: "App",
      workspace: "App/App.xcworkspace",
      configuration: "Release",
      export_method: "ad-hoc",
      codesigning_identity: "Apple Distribution",
      clean: true,
      include_bitcode: false, # Bitcode deprecated in Xcode 16
      include_symbols: true,
      xcargs: "CODE_SIGN_IDENTITY='Apple Distribution' CODE_SIGN_STYLE=Manual PROVISIONING_PROFILE_SPECIFIER='match AdHoc app.cawcaw' OTHER_CODE_SIGN_FLAGS='--keychain build.keychain' -allowProvisioningUpdates",
      export_options: {
        method: "ad-hoc",
        signingStyle: "manual",
        provisioningProfiles: {
          "app.cawcaw" => "match AdHoc app.cawcaw"
        },
        signingCertificate: "Apple Distribution",
        compileBitcode: false,
        uploadBitcode: false,
        uploadSymbols: true,
        thinning: "<none>"
      },
      output_name: "caw_caw"
    )
    
    # Success notification
    if ENV['CI']
      puts "‚úÖ Successfully built Ad Hoc distribution!"
      puts "üìÅ IPA Location: #{lane_context[SharedValues::IPA_OUTPUT_PATH]}"
      puts "üì± Ready for direct device installation"
    end
  end

  # Error handling
  error do |lane, exception|
    puts "‚ùå Error in lane #{lane}: #{exception}"
    if ENV['CI']
      puts "Check the GitHub Actions logs for more details"
    end
  end
end